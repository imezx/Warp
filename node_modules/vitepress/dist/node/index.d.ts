import * as vite from 'vite';
import { Logger, UserConfig as UserConfig$1, ConfigEnv, BuildOptions, ServerOptions } from 'vite';
export { ConfigEnv, Plugin, loadEnv } from 'vite';
import MarkdownIt, { Options as Options$2, PresetName, PluginSimple as PluginSimple$1, PluginWithOptions as PluginWithOptions$1, PluginWithParams as PluginWithParams$1 } from 'markdown-it';
import { PageSplitSection } from '../../types/local-search.js';
import { SiteData, MarkdownEnv, Awaitable, LocaleSpecificConfig, LocaleConfig, SSGContext, PageData, HeadConfig, AdditionalConfigDict, AdditionalConfigLoader, AdditionalConfig } from '../../types/shared.js';
export { HeadConfig, Header, SiteData } from '../../types/shared.js';
import { Options as Options$3 } from '@vitejs/plugin-vue';
import { UseDarkOptions } from '@vueuse/core';
import { TransformOptions } from 'node:stream';
import { ThemeRegistrationAny, LanguageInput, ShikiTransformer } from '@shikijs/types';
import Token from 'markdown-it/lib/token.mjs';
import State from 'markdown-it/lib/rules_core/state_core.mjs';
import { BuiltinTheme, BuiltinLanguage, Highlighter } from 'shiki';
import { DefaultTheme } from '../../types/default-theme.js';
export { DefaultTheme } from '../../types/default-theme.js';
import { Plugin } from 'postcss';
import { IncomingMessage, ServerResponse } from 'http';
import { Server, ListenOptions } from 'net';

type PluginSimple = ((md: MarkdownItAsync) => void);
type PluginWithOptions<T = any> = ((md: MarkdownItAsync, options?: T) => void);
type PluginWithParams = ((md: MarkdownItAsync, ...params: any[]) => void);
interface MarkdownItAsyncOptions extends Omit<Options$2, 'highlight'> {
    /**
     * Highlighter function for fenced code blocks.
     * Highlighter `function (str, lang, attrs)` should return escaped HTML. It can
     * also return empty string if the source was not changed and should be escaped
     * externally. If result starts with <pre... internal wrapper is skipped.
     * @default null
     */
    highlight?: ((str: string, lang: string, attrs: string) => string | Promise<string>) | null | undefined;
    /**
     * Emit warning when calling `md.render` instead of `md.renderAsync`.
     *
     * @default false
     */
    warnOnSyncRender?: boolean;
}

type MarkdownItAsyncPlaceholderMap = Map<string, [promise: Promise<string>, str: string, lang: string, attrs: string]>;
declare class MarkdownItAsync extends MarkdownIt {
     // @ts-ignore
    options: MarkdownItAsyncOptions
    placeholderMap: MarkdownItAsyncPlaceholderMap;
    private disableWarn;
    constructor(presetName: PresetName, options?: MarkdownItAsyncOptions);
    constructor(options?: MarkdownItAsyncOptions);
    use(plugin: PluginSimple): this;
    use(plugin: PluginSimple$1): this;
    use<T = any>(plugin: PluginWithOptions<T>, options?: T): this;
    use<T = any>(plugin: PluginWithOptions$1<T>, options?: T): this;
    use(plugin: PluginWithParams, ...params: any[]): this;
    use(plugin: PluginWithParams$1, ...params: any[]): this;
    render(src: string, env?: any): string;
    renderAsync(src: string, env?: any): Promise<string>;
}

/**
 * this merges the locales data to the main data by the route
 */
declare function resolveSiteDataByRoute(siteData: SiteData, relativePath: string): SiteData;

declare module '../../types/default-theme.js' {
    namespace DefaultTheme {
        interface LocalSearchOptions {
            /**
             * Allows transformation of content before indexing (node only)
             * Return empty string to skip indexing
             */
            _render?: (src: string, env: MarkdownEnv, md: MarkdownItAsync) => Awaitable<string>;
        }
        interface MiniSearchOptions {
            /**
             * Overrides the default regex based page splitter.
             * Supports async generator, making it possible to run in true parallel
             * (when used along with `node:child_process` or `worker_threads`)
             * ---
             * This should be especially useful for scalability reasons.
             * ---
             * @param {string} path - absolute path to the markdown source file
             * @param {string} html - document page rendered as html
             */
            _splitIntoSections?: (path: string, html: string) => AsyncGenerator<PageSplitSection> | Generator<PageSplitSection> | Awaitable<PageSplitSection[]>;
        }
    }
}

/**
 * How frequently the page is likely to change. This value provides general
 * information to search engines and may not correlate exactly to how often they crawl the page. Please note that the
 * value of this tag is considered a hint and not a command. See
 * <https://www.sitemaps.org/protocol.html#xmlTagDefinitions> for the acceptable
 * values
 */
declare enum EnumChangefreq {
    DAILY = "daily",
    MONTHLY = "monthly",
    ALWAYS = "always",
    HOURLY = "hourly",
    WEEKLY = "weekly",
    YEARLY = "yearly",
    NEVER = "never"
}
/**
 * https://support.google.com/webmasters/answer/74288?hl=en&ref_topic=4581190
 */
interface NewsItem {
    access?: 'Registration' | 'Subscription';
    publication: {
        name: string;
        /**
         * The `<language>` is the language of your publication. Use an ISO 639
         * language code (2 or 3 letters).
         */
        language: string;
    };
    /**
     * @example 'PressRelease, Blog'
     */
    genres?: string;
    /**
     * Article publication date in W3C format, using either the "complete date" (YYYY-MM-DD) format or the "complete date
     * plus hours, minutes, and seconds"
     */
    publication_date: string;
    /**
     * The title of the news article
     * @example 'Companies A, B in Merger Talks'
     */
    title: string;
    /**
     * @example 'business, merger, acquisition'
     */
    keywords?: string;
    /**
     * @example 'NASDAQ:A, NASDAQ:B'
     */
    stock_tickers?: string;
}
/**
 * Sitemap Image
 * https://support.google.com/webmasters/answer/178636?hl=en&ref_topic=4581190
 */
interface Img {
    /**
     * The URL of the image
     * @example 'https://example.com/image.jpg'
     */
    url: string;
    /**
     * The caption of the image
     * @example 'Thanksgiving dinner'
     */
    caption?: string;
    /**
     * The title of the image
     * @example 'Star Wars EP IV'
     */
    title?: string;
    /**
     * The geographic location of the image.
     * @example 'Limerick, Ireland'
     */
    geoLocation?: string;
    /**
     * A URL to the license of the image.
     * @example 'https://example.com/license.txt'
     */
    license?: string;
}
/**
 * https://support.google.com/webmasters/answer/189077
 */
interface LinkItem {
    /**
     * @example 'en'
     */
    lang: string;
    /**
     * @example 'en-us'
     */
    hreflang?: string;
    url: string;
}
/**
 * How to handle errors in passed in urls
 */
declare enum ErrorLevel {
    /**
     * Validation will be skipped and nothing logged or thrown.
     */
    SILENT = "silent",
    /**
     * If an invalid value is encountered, a console.warn will be called with details
     */
    WARN = "warn",
    /**
     * An Error will be thrown on encountering invalid data.
     */
    THROW = "throw"
}
type ErrorHandler$1 = (error: Error, level: ErrorLevel) => void;

interface NSArgs {
    news: boolean;
    video: boolean;
    xhtml: boolean;
    image: boolean;
    custom?: string[];
}
interface SitemapStreamOptions extends TransformOptions {
    hostname?: string;
    level?: ErrorLevel;
    lastmodDateOnly?: boolean;
    xmlns?: NSArgs;
    xslUrl?: string;
    errorHandler?: ErrorHandler$1;
}

interface SitemapItem {
    lastmod?: string | number | Date;
    changefreq?: `${EnumChangefreq}`;
    fullPrecisionPriority?: boolean;
    priority?: number;
    news?: NewsItem;
    expires?: string;
    androidLink?: string;
    ampLink?: string;
    url: string;
    video?: any;
    img?: string | Img | (string | Img)[];
    links?: LinkItem[];
    lastmodfile?: string | Buffer | URL;
    lastmodISO?: string;
    lastmodrealtime?: boolean;
}

//#region src/types.d.ts
/**
 * Options of @mdit-vue/plugin-component
 */
interface ComponentPluginOptions {
  /**
   * Extra tags to be treated as block tags.
   *
   * @default []
   */
  blockTags?: string[];
  /**
   * Extra tags to be treated as inline tags.
   *
   * @default []
   */
  inlineTags?: string[];
}

/**
 * Takes a string or object with `content` property, extracts
 * and parses front-matter from the string, then returns an object
 * with `data`, `content` and other [useful properties](#returned-object).
 *
 * ```js
 * var matter = require('gray-matter');
 * console.log(matter('---\ntitle: Home\n---\nOther stuff'));
 * //=> { data: { title: 'Home'}, content: 'Other stuff' }
 * ```
 * @param {Object|String} `input` String, or object with `content` string
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */
declare function matter<
  I extends matter.Input,
  O extends matter.GrayMatterOption<I, O>
>(input: I | { content: I }, options?: O): matter.GrayMatterFile<I>

declare namespace matter {
  type Input = string | Buffer
  interface GrayMatterOption<
    I extends Input,
    O extends GrayMatterOption<I, O>
  > {
    parser?: () => void
    eval?: boolean
    excerpt?: boolean | ((input: I, options: O) => string)
    excerpt_separator?: string
    engines?: {
      [index: string]:
        | ((input: string) => object)
        | { parse: (input: string) => object; stringify?: (data: object) => string }
    }
    language?: string
    delimiters?: string | [string, string]
  }
  interface GrayMatterFile<I extends Input> {
    data: { [key: string]: any }
    content: string
    excerpt?: string
    orig: Buffer | I
    language: string
    matter: string
    stringify(lang: string): string
  }
  
  /**
   * Stringify an object to YAML or the specified language, and
   * append it to the given string. By default, only YAML and JSON
   * can be stringified. See the [engines](#engines) section to learn
   * how to stringify other languages.
   *
   * ```js
   * console.log(matter.stringify('foo bar baz', {title: 'Home'}));
   * // results in:
   * // ---
   * // title: Home
   * // ---
   * // foo bar baz
   * ```
   * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.
   * @param {Object} `data` Front matter to stringify.
   * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].
   * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.
   */
  export function stringify<O extends GrayMatterOption<string, O>>(
    file: string | { content: string },
    data: object,
    options?: GrayMatterOption<string, O>
  ): string

  /**
   * Synchronously read a file from the file system and parse
   * front matter. Returns the same object as the [main function](#matter).
   *
   * ```js
   * var file = matter.read('./content/blog-post.md');
   * ```
   * @param {String} `filepath` file path of the file to read.
   * @param {Object} `options` [Options](#options) to pass to gray-matter.
   * @return {Object} Returns [an object](#returned-object) with `data` and `content`
   */
  export function read<O extends GrayMatterOption<string, O>>(
    fp: string,
    options?: GrayMatterOption<string, O>
  ): matter.GrayMatterFile<string>

  /**
   * Returns true if the given `string` has front matter.
   * @param  {String} `string`
   * @param  {Object} `options`
   * @return {Boolean} True if front matter exists.
   */
  export function test<O extends matter.GrayMatterOption<string, O>>(
    str: string,
    options?: GrayMatterOption<string, O>
  ): boolean

  /**
   * Detect the language to use, if one is defined after the
   * first front-matter delimiter.
   * @param  {String} `string`
   * @param  {Object} `options`
   * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed
   */
  export function language<O extends matter.GrayMatterOption<string, O>>(
    str: string,
    options?: GrayMatterOption<string, O>
  ): { name: string; raw: string }
}

//#region src/types.d.ts
type GrayMatterOptions = matter.GrayMatterOption<string, GrayMatterOptions>;
/**
 * Options of @mdit-vue/plugin-frontmatter
 */
interface FrontmatterPluginOptions {
  /**
   * Options of gray-matter
   *
   * @see https://github.com/jonschlinkert/gray-matter#options
   */
  grayMatterOptions?: GrayMatterOptions;
  /**
   * Render the excerpt or not
   *
   * @default true
   */
  renderExcerpt?: boolean;
}
declare module '@mdit-vue/types' {
  interface MarkdownItEnv {
    /**
     * The raw Markdown content without frontmatter
     */
    content?: string;
    /**
     * The excerpt that extracted by `@mdit-vue/plugin-frontmatter`
     *
     * - Would be the rendered HTML when `renderExcerpt` is enabled
     * - Would be the raw Markdown when `renderExcerpt` is disabled
     */
    excerpt?: string;
    /**
     * The frontmatter that extracted by `@mdit-vue/plugin-frontmatter`
     */
    frontmatter?: Record<string, unknown>;
  }
}

interface MarkdownItHeader {
  /**
   * The level of the header
   *
   * `1` to `6` for `<h1>` to `<h6>`
   */
  level: number;
  /**
   * The title of the header
   */
  title: string;
  /**
   * The slug of the header
   *
   * Typically the `id` attr of the header anchor
   */
  slug: string;
  /**
   * Link of the header
   *
   * Typically using `#${slug}` as the anchor hash
   */
  link: string;
  /**
   * The children of the header
   */
  children: MarkdownItHeader[];
}

//#region src/types.d.ts

/**
 * Options of @mdit-vue/plugin-headers
 */
interface HeadersPluginOptions {
  /**
   * A custom slugification function
   *
   * Should use the same slugify function with markdown-it-anchor
   * to ensure the link is matched
   */
  slugify?: (str: string) => string;
  /**
   * A function for formatting header title
   */
  format?: (str: string) => string;
  /**
   * Heading level that going to be extracted
   *
   * Should be a subset of markdown-it-anchor's `level` option
   * to ensure the slug is existed
   *
   * @default [2,3]
   */
  level?: number[];
  /**
   * Should allow headers inside nested blocks or not
   *
   * If set to `true`, headers inside blockquote, list, etc. would also be extracted.
   *
   * @default false
   */
  shouldAllowNested?: boolean;
}
declare module '@mdit-vue/types' {
  interface MarkdownItEnv {
    /**
     * The headers that extracted by `@mdit-vue/plugin-headers`
     */
    headers?: MarkdownItHeader[];
  }
}

//#endregion
//#region src/types.d.ts
/**
 * Options of @mdit-vue/plugin-sfc
 */
interface SfcPluginOptions {
  /**
   * Custom blocks to be extracted
   *
   * @default []
   */
  customBlocks?: string[];
}
/**
 * SFC block that extracted from markdown
 */
interface SfcBlock {
  /**
   * The type of the block
   */
  type: string;
  /**
   * The content, including open-tag and close-tag
   */
  content: string;
  /**
   * The content that stripped open-tag and close-tag off
   */
  contentStripped: string;
  /**
   * The open-tag
   */
  tagOpen: string;
  /**
   * The close-tag
   */
  tagClose: string;
}
interface MarkdownSfcBlocks {
  /**
   * The `<template>` block
   */
  template: SfcBlock | null;
  /**
   * The common `<script>` block
   */
  script: SfcBlock | null;
  /**
   * The `<script setup>` block
   */
  scriptSetup: SfcBlock | null;
  /**
   * All `<script>` blocks.
   *
   * By default, SFC only allows one `<script>` block and one `<script setup>` block.
   * However, some tools may support different types of `<script>`s, so we keep all of them here.
   */
  scripts: SfcBlock[];
  /**
   * All `<style>` blocks.
   */
  styles: SfcBlock[];
  /**
   * All custom blocks.
   */
  customBlocks: SfcBlock[];
}
declare module '@mdit-vue/types' {
  interface MarkdownItEnv {
    /**
     * SFC blocks that extracted by `@mdit-vue/plugin-sfc`
     */
    sfcBlocks?: MarkdownSfcBlocks;
  }
}

//#region src/types.d.ts
/**
 * Options of @mdit-vue/plugin-toc
 */
interface TocPluginOptions {
  /**
   * The pattern serving as the TOC placeholder in your markdown
   *
   * @default /^\[\[toc\]\]$/i
   */
  pattern?: RegExp;
  /**
   * A custom slugification function
   *
   * Should use the same slugify function with markdown-it-anchor
   * to ensure the link is matched
   */
  slugify?: (str: string) => string;
  /**
   * A function for formatting headings
   */
  format?: (str: string) => string;
  /**
   * Heading level that going to be included in the TOC
   *
   * Should be a subset of markdown-it-anchor's `level` option
   * to ensure the link is existed
   *
   * @default [2,3]
   */
  level?: number[];
  /**
   * Should allow headers inside nested blocks or not
   *
   * If set to `true`, headers inside blockquote, list, etc. would also be included.
   *
   * @default false
   */
  shouldAllowNested?: boolean;
  /**
   * HTML tag of the TOC container
   *
   * @default 'nav'
   */
  containerTag?: string;
  /**
   * The class for the TOC container
   *
   * @default 'table-of-contents'
   */
  containerClass?: string;
  /**
   * HTML tag of the TOC list
   *
   * @default 'ul'
   */
  listTag?: 'ol' | 'ul';
  /**
   * The class for the TOC list
   *
   * @default ''
   */
  listClass?: string;
  /**
   * The class for the `<li>` tag
   *
   * @default ''
   */
  itemClass?: string;
  /**
   * The tag of the link inside `<li>` tag
   *
   * @default 'a'
   */
  linkTag?: 'a' | 'router-link';
  /**
   * The class for the link inside the `<li>` tag
   *
   * @default ''
   */
  linkClass?: string;
}

declare namespace anchor {
  export type RenderHref = (slug: string, state: State) => string;
  export type RenderAttrs = (slug: string, state: State) => Record<string, string | number>;

  export interface PermalinkOptions {
    class?: string,
    symbol?: string,
    renderHref?: RenderHref,
    renderAttrs?: RenderAttrs
  }

  export interface HeaderLinkPermalinkOptions extends PermalinkOptions {
    safariReaderFix?: boolean;
  }

  export interface LinkAfterHeaderPermalinkOptions extends PermalinkOptions {
    style?: 'visually-hidden' | 'aria-label' | 'aria-describedby' | 'aria-labelledby',
    assistiveText?: (title: string) => string,
    visuallyHiddenClass?: string,
    space?: boolean | string,
    placement?: 'before' | 'after'
    wrapper?: [string, string] | null
  }

  export interface LinkInsideHeaderPermalinkOptions extends PermalinkOptions {
    space?: boolean | string,
    placement?: 'before' | 'after',
    ariaHidden?: boolean
  }

  export interface AriaHiddenPermalinkOptions extends PermalinkOptions {
    space?: boolean | string,
    placement?: 'before' | 'after'
  }

  export type PermalinkGenerator = (slug: string, opts: PermalinkOptions, state: State, index: number) => void;

  export interface AnchorInfo {
    slug: string;
    title: string;
  }

  export interface AnchorOptions {
    level?: number | number[];

    slugify?(str: string): string;
    slugifyWithState?(str: string, state: State): string;
    getTokensText?(tokens: Token[]): string;

    uniqueSlugStartIndex?: number;
    permalink?: PermalinkGenerator;

    callback?(token: Token, anchor_info: AnchorInfo): void;

    tabIndex?: number | false;
  }

  export const permalink: {
    headerLink: (opts?: HeaderLinkPermalinkOptions) => PermalinkGenerator
    linkAfterHeader: (opts?: LinkAfterHeaderPermalinkOptions) => PermalinkGenerator
    linkInsideHeader: (opts?: LinkInsideHeaderPermalinkOptions) => PermalinkGenerator
    ariaHidden: (opts?: AriaHiddenPermalinkOptions) => PermalinkGenerator
  };
}

declare function anchor(md: MarkdownIt, opts?: anchor.AnchorOptions): void;

interface MarkdownItAttrsOptions {
  /** left delimiter, default is `{`(left curly bracket) */
  leftDelimiter?: string
  /** right delimiter, default is `}`(right curly bracket) */
  rightDelimiter?: string
  /** rule of allowed attribute, empty means no limit */
  allowedAttributes?: (string | RegExp)[]
}

interface ContainerOptions {
    infoLabel?: string;
    noteLabel?: string;
    tipLabel?: string;
    warningLabel?: string;
    dangerLabel?: string;
    detailsLabel?: string;
    importantLabel?: string;
    cautionLabel?: string;
}

interface Options$1 {
    /**
     * Support native lazy loading for the `<img>` tag.
     * @default false
     */
    lazyLoading?: boolean;
}

type ThemeOptions = ThemeRegistrationAny | BuiltinTheme | {
    light: ThemeRegistrationAny | BuiltinTheme;
    dark: ThemeRegistrationAny | BuiltinTheme;
};
interface MarkdownOptions extends MarkdownItAsyncOptions {
    /**
     * Setup markdown-it instance before applying plugins
     */
    preConfig?: (md: MarkdownItAsync) => Awaitable<void>;
    /**
     * Setup markdown-it instance
     */
    config?: (md: MarkdownItAsync) => Awaitable<void>;
    /**
     * Disable cache (experimental)
     */
    cache?: boolean;
    externalLinks?: Record<string, string>;
    /**
     * Custom theme for syntax highlighting.
     *
     * You can also pass an object with `light` and `dark` themes to support dual themes.
     *
     * @example { theme: 'github-dark' }
     * @example { theme: { light: 'github-light', dark: 'github-dark' } }
     *
     * You can use an existing theme.
     * @see https://shiki.style/themes
     * Or add your own theme.
     * @see https://shiki.style/guide/load-theme
     */
    theme?: ThemeOptions;
    /**
     * Custom languages for syntax highlighting or pre-load built-in languages.
     * @see https://shiki.style/languages
     */
    languages?: (LanguageInput | BuiltinLanguage)[];
    /**
     * Custom language aliases for syntax highlighting.
     * Maps custom language names to existing languages.
     * Alias lookup is case-insensitive and underscores in language names are displayed as spaces.
     *
     * @example
     *
     * Maps `my_lang` to use Python syntax highlighting.
     * ```js
     * { 'my_lang': 'python' }
     * ```
     *
     * Usage in markdown:
     * ````md
     * ```My_Lang
     * # This will be highlighted as Python code
     * # and will show "My Lang" as the language label
     * print("Hello, World!")
     * ```
     * ````
     *
     * @see https://shiki.style/guide/load-lang#custom-language-aliases
     */
    languageAlias?: Record<string, string>;
    /**
     * Custom language labels for display.
     * Overrides the default language label shown in code blocks.
     * Keys are case-insensitive.
     *
     * @example { 'vue': 'Vue SFC' }
     */
    languageLabel?: Record<string, string>;
    /**
     * Show line numbers in code blocks
     * @default false
     */
    lineNumbers?: boolean;
    /**
     * Fallback language when the specified language is not available.
     */
    defaultHighlightLang?: string;
    /**
     * Transformers applied to code blocks
     * @see https://shiki.style/guide/transformers
     */
    codeTransformers?: ShikiTransformer[];
    /**
     * Setup Shiki instance
     */
    shikiSetup?: (shiki: Highlighter) => void | Promise<void>;
    /**
     * The tooltip text for the copy button in code blocks
     * @default 'Copy Code'
     */
    codeCopyButtonTitle?: string;
    /**
     * Options for `markdown-it-anchor`
     * @see https://github.com/valeriangalliat/markdown-it-anchor
     */
    anchor?: anchor.AnchorOptions;
    /**
     * Options for `markdown-it-attrs`
     * @see https://github.com/arve0/markdown-it-attrs
     */
    attrs?: MarkdownItAttrsOptions & {
        disable?: boolean;
    };
    /**
     * Options for `markdown-it-emoji`
     * @see https://github.com/markdown-it/markdown-it-emoji
     */
    emoji?: {
        defs?: Record<string, string>;
        enabled?: string[];
        shortcuts?: Record<string, string | string[]>;
    };
    /**
     * Options for `@mdit-vue/plugin-frontmatter`
     * @see https://github.com/mdit-vue/mdit-vue/tree/main/packages/plugin-frontmatter
     */
    frontmatter?: FrontmatterPluginOptions;
    /**
     * Options for `@mdit-vue/plugin-headers`
     * @see https://github.com/mdit-vue/mdit-vue/tree/main/packages/plugin-headers
     */
    headers?: HeadersPluginOptions | boolean;
    /**
     * Options for `@mdit-vue/plugin-sfc`
     * @see https://github.com/mdit-vue/mdit-vue/tree/main/packages/plugin-sfc
     */
    sfc?: SfcPluginOptions;
    /**
     * Options for `@mdit-vue/plugin-toc`
     * @see https://github.com/mdit-vue/mdit-vue/tree/main/packages/plugin-toc
     */
    toc?: TocPluginOptions;
    /**
     * Options for `@mdit-vue/plugin-component`
     * @see https://github.com/mdit-vue/mdit-vue/tree/main/packages/plugin-component
     */
    component?: ComponentPluginOptions;
    /**
     * Options for `markdown-it-container`
     * @see https://github.com/markdown-it/markdown-it-container
     */
    container?: ContainerOptions;
    /**
     * Math support
     *
     * You need to install `markdown-it-mathjax3` and set `math` to `true` to enable it.
     * You can also pass options to `markdown-it-mathjax3` here.
     * @default false
     * @see https://vitepress.dev/guide/markdown#math-equations
     */
    math?: boolean | any;
    image?: Options$1;
    /**
     * Allows disabling the github alerts plugin
     * @default true
     * @see https://vitepress.dev/guide/markdown#github-flavored-alerts
     */
    gfmAlerts?: boolean;
    /**
     * Allows disabling the CJK-friendly plugin.
     * This plugin adds support for emphasis marks (**bold**) in Japanese, Chinese, and Korean text.
     * @default true
     * @see https://github.com/tats-u/markdown-cjk-friendly
     */
    cjkFriendlyEmphasis?: boolean;
    /**
     * @see cjkFriendlyEmphasis
     * @deprecated use `cjkFriendly` instead
     */
    cjkFriendly?: boolean;
}
type MarkdownRenderer = MarkdownItAsync;
declare function disposeMdItInstance(): void;
/**
 * @experimental
 */
declare function createMarkdownRenderer(srcDir: string, options?: MarkdownOptions, base?: string, logger?: Pick<Logger, 'warn'>): Promise<MarkdownRenderer>;

interface GlobOptions {
    absolute?: boolean;
    cwd?: string;
    ignore?: string | string[];
    dot?: boolean;
    debug?: boolean;
}

interface UserRouteConfig {
    params: Record<string, string>;
    content?: string;
}
type ResolvedRouteConfig = UserRouteConfig & {
    /**
     * the raw route (relative to src root), e.g. foo/[bar].md
     */
    route: string;
    /**
     * the actual path with params resolved (relative to src root), e.g. foo/1.md
     */
    path: string;
    /**
     * absolute fs path
     */
    fullPath: string;
    /**
     * the path to the paths loader module
     */
    loaderPath: string;
};
interface RouteModule {
    watch?: string[] | string;
    paths: UserRouteConfig[] | ((watchedFiles: string[]) => Awaitable<UserRouteConfig[]>);
    transformPageData?: UserConfig['transformPageData'];
    options?: {
        globOptions?: GlobOptions;
    };
}
/**
 * Helper for defining routes with type inference
 */
declare function defineRoutes(loader: RouteModule): RouteModule;
type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
declare function resolvePages(siteConfig: Optional<SiteConfig, 'pages' | 'dynamicRoutes' | 'rewrites'>, rebuildCache?: boolean): Promise<void>;

type RawConfigExports<ThemeConfig = any> = Awaitable<UserConfig<ThemeConfig>> | (() => Awaitable<UserConfig<ThemeConfig>>);
interface TransformContext<ThemeConfig = any> {
    page: string;
    siteConfig: SiteConfig<ThemeConfig>;
    siteData: SiteData;
    pageData: PageData;
    title: string;
    description: string;
    head: HeadConfig[];
    content: string;
    assets: string[];
}
interface TransformPageContext<ThemeConfig = any> {
    siteConfig: SiteConfig<ThemeConfig>;
}
interface UserConfig<ThemeConfig = any> extends LocaleSpecificConfig<ThemeConfig> {
    extends?: RawConfigExports<ThemeConfig>;
    base?: string;
    srcDir?: string;
    srcExclude?: string[];
    outDir?: string;
    assetsDir?: string;
    cacheDir?: string;
    shouldPreload?: (link: string, page: string) => boolean;
    locales?: LocaleConfig<ThemeConfig>;
    router?: {
        prefetchLinks?: boolean;
    };
    appearance?: boolean | 'dark' | 'force-dark' | 'force-auto' | (Omit<UseDarkOptions, 'initialValue'> & {
        initialValue?: 'dark';
    });
    lastUpdated?: boolean;
    contentProps?: Record<string, any>;
    /**
     * MarkdownIt options
     */
    markdown?: MarkdownOptions;
    /**
     * Options to pass on to `@vitejs/plugin-vue`
     */
    vue?: Options$3;
    /**
     * Vite config
     */
    vite?: UserConfig$1 & {
        configFile?: string | false;
    };
    /**
     * Configure the scroll offset when the theme has a sticky header.
     * Can be a number or a selector element to get the offset from.
     * Can also be an array of selectors in case some elements will be
     * invisible due to responsive layout. VitePress will fallback to the next
     * selector if a selector fails to match, or the matched element is not
     * currently visible in viewport.
     */
    scrollOffset?: number | string | string[] | {
        selector: string | string[];
        padding: number;
    };
    /**
     * Enable MPA / zero-JS mode.
     * @experimental
     */
    mpa?: boolean;
    /**
     * Extracts metadata to a separate chunk.
     * @experimental
     */
    metaChunk?: boolean;
    /**
     * Don't fail builds due to dead links.
     *
     * @default false
     */
    ignoreDeadLinks?: boolean | 'localhostLinks' | (string | RegExp | ((link: string, source: string) => boolean))[];
    /**
     * Don't force `.html` on URLs.
     *
     * @default false
     */
    cleanUrls?: boolean;
    /**
     * Use web fonts instead of emitting font files to dist.
     * The used theme should import a file named `fonts.(s)css` for this to work.
     * If you are a theme author, to support this, place your web font import
     * between `webfont-marker-begin` and `webfont-marker-end` comments.
     *
     * @default true in webcontainers, else false
     */
    useWebFonts?: boolean;
    /**
     * This option allows you to configure the concurrency of the build.
     * A lower number will reduce the memory usage but will increase the build time.
     *
     * @experimental
     * @default 64
     */
    buildConcurrency?: number;
    /**
     * @experimental
     *
     * source -> destination
     */
    rewrites?: Record<string, string> | ((id: string) => string);
    /**
     * @experimental
     */
    sitemap?: SitemapStreamOptions & {
        hostname: string;
        transformItems?: (items: SitemapItem[]) => Awaitable<SitemapItem[]>;
    };
    /**
     * Build end hook: called when SSG finish.
     * @param siteConfig The resolved configuration.
     */
    buildEnd?: (siteConfig: SiteConfig<ThemeConfig>) => Awaitable<void>;
    /**
     * Render end hook: called when SSR rendering is done.
     */
    postRender?: (context: SSGContext) => Awaitable<SSGContext | void>;
    /**
     * Head transform hook: runs before writing HTML to dist.
     *
     * This build hook will allow you to modify the head adding new entries that cannot be statically added.
     */
    transformHead?: (ctx: TransformContext<ThemeConfig>) => Awaitable<HeadConfig[] | void>;
    /**
     * HTML transform hook: runs before writing HTML to dist.
     */
    transformHtml?: (code: string, id: string, ctx: TransformContext<ThemeConfig>) => Awaitable<string | void>;
    /**
     * PageData transform hook: runs when rendering markdown to vue
     */
    transformPageData?: (pageData: PageData, ctx: TransformPageContext<ThemeConfig>) => Awaitable<Partial<PageData> | {
        [key: string]: any;
    } | void>;
    /**
     * Multi-layer configuration overloading.
     * Auto-resolves to `docs/.../config.{js,mjs,ts,mts}` when unspecified.
     *
     * Set to `{}` to opt-out.
     *
     * @experimental
     */
    additionalConfig?: AdditionalConfigDict<ThemeConfig> | AdditionalConfigLoader<ThemeConfig>;
}
interface SiteConfig<ThemeConfig = any> extends Pick<UserConfig<ThemeConfig>, 'markdown' | 'vue' | 'vite' | 'shouldPreload' | 'router' | 'mpa' | 'metaChunk' | 'lastUpdated' | 'ignoreDeadLinks' | 'cleanUrls' | 'useWebFonts' | 'postRender' | 'buildEnd' | 'transformHead' | 'transformHtml' | 'transformPageData' | 'sitemap'> {
    root: string;
    srcDir: string;
    site: SiteData<ThemeConfig>;
    configPath: string | undefined;
    configDeps: string[];
    themeDir: string;
    outDir: string;
    assetsDir: string;
    cacheDir: string;
    tempDir: string;
    pages: string[];
    dynamicRoutes: ResolvedRouteConfig[];
    rewrites: {
        map: Record<string, string | undefined>;
        inv: Record<string, string | undefined>;
    };
    logger: Logger;
    userConfig: UserConfig<ThemeConfig>;
    buildConcurrency: number;
}

type UserConfigFn<ThemeConfig> = (env: ConfigEnv) => Awaitable<UserConfig<ThemeConfig>>;
type UserConfigExport<ThemeConfig> = Awaitable<UserConfig<ThemeConfig>> | UserConfigFn<ThemeConfig>;
/**
 * Type config helper
 */
declare function defineConfig<ThemeConfig = DefaultTheme.Config>(config: UserConfig<NoInfer<ThemeConfig>>): UserConfig<NoInfer<ThemeConfig>>;
type AdditionalConfigFn<ThemeConfig> = (env: ConfigEnv) => Awaitable<AdditionalConfig<ThemeConfig>>;
type AdditionalConfigExport<ThemeConfig> = Awaitable<AdditionalConfig<ThemeConfig>> | AdditionalConfigFn<ThemeConfig>;
/**
 *  Type config helper for additional/locale-specific config
 */
declare function defineAdditionalConfig<ThemeConfig = DefaultTheme.Config>(config: AdditionalConfig<NoInfer<ThemeConfig>>): AdditionalConfig<NoInfer<ThemeConfig>>;
/**
 * Type config helper for custom theme config
 *
 * @deprecated use `defineConfig` instead
 */
declare function defineConfigWithTheme<ThemeConfig>(config: UserConfig<ThemeConfig>): UserConfig<ThemeConfig>;
declare function resolveConfig(root?: string, command?: 'serve' | 'build', mode?: string): Promise<SiteConfig>;
declare function isAdditionalConfigFile(path: string): boolean;
declare function resolveUserConfig(root: string, command: 'serve' | 'build', mode: string): Promise<[UserConfig, configPath: string | undefined, configDeps: string[]]>;
declare function mergeConfig(a: UserConfig, b: UserConfig, isRoot?: boolean): Record<string, any>;
declare function resolveSiteData(root: string, userConfig?: UserConfig, command?: 'serve' | 'build', mode?: string): Promise<SiteData>;

declare function build(root?: string, buildOptions?: BuildOptions & {
    base?: string;
    mpa?: string;
    onAfterConfigResolve?: (siteConfig: SiteConfig) => Awaitable<void>;
}): Promise<void>;

interface ContentOptions<T = ContentData[]> {
    /**
     * Include src?
     * @default false
     */
    includeSrc?: boolean;
    /**
     * Render src to HTML and include in data?
     * @default false
     */
    render?: boolean;
    /**
     * If `boolean`, whether to parse and include excerpt? (rendered as HTML)
     *
     * If `function`, control how the excerpt is extracted from the content.
     *
     * If `string`, define a custom separator to be used for extracting the
     * excerpt. Default separator is `---` if `excerpt` is `true`.
     *
     * @see https://github.com/jonschlinkert/gray-matter#optionsexcerpt
     * @see https://github.com/jonschlinkert/gray-matter#optionsexcerpt_separator
     *
     * @default false
     */
    excerpt?: boolean | ((file: {
        data: {
            [key: string]: any;
        };
        content: string;
        excerpt?: string;
    }, options?: any) => void) | string;
    /**
     * Transform the data. Note the data will be inlined as JSON in the client
     * bundle if imported from components or markdown files.
     */
    transform?: (data: ContentData[]) => Awaitable<T>;
    /**
     * Options to pass to `tinyglobby` and `picomatch` for globbing.
     */
    globOptions?: GlobOptions;
}
interface ContentData {
    url: string;
    src: string | undefined;
    html: string | undefined;
    frontmatter: Record<string, any>;
    excerpt: string | undefined;
}
/**
 * Create a loader object that can be directly used as the default export
 * of a data loader file.
 */
declare function createContentLoader<T = ContentData[]>(
/**
 * files to glob / watch - relative to srcDir
 */
watch: string | string[], options?: ContentOptions<T>): {
    watch: string[];
    options: {
        globOptions: GlobOptions | undefined;
    };
    load(files?: string[]): Promise<T>;
};

declare enum ScaffoldThemeType {
    Default = "default theme",
    DefaultCustom = "default theme + customization",
    Custom = "custom theme"
}
interface ScaffoldOptions {
    root?: string;
    srcDir?: string;
    title?: string;
    description?: string;
    theme?: ScaffoldThemeType;
    useTs?: boolean;
    injectNpmScripts?: boolean;
    addNpmScriptsPrefix?: boolean;
    npmScriptsPrefix?: string;
}
declare function init(root?: string): Promise<void>;
declare function scaffold({ root: root_, srcDir: srcDir_, title, description, theme, useTs, injectNpmScripts, addNpmScriptsPrefix, npmScriptsPrefix }: ScaffoldOptions): string;

interface LoaderModule<T = any> {
    watch?: string[] | string;
    load: (watchedFiles: string[]) => Awaitable<T>;
    options?: {
        globOptions?: GlobOptions;
    };
}
/**
 * Helper for defining loaders with type inference
 */
declare function defineLoader<T>(loader: LoaderModule<T>): LoaderModule<T>;

type Options = {
    includeFiles?: RegExp[];
    ignoreFiles?: RegExp[];
    prefix?: string;
};
declare function postcssIsolateStyles({ includeFiles, ignoreFiles, prefix }?: Options): Plugin;

interface ParsedURL {
	pathname: string;
	search: string;
	query: Record<string, string | string[]> | undefined;
	hash: string | undefined;
	raw: string;
}

// Thank you: @fwilkerson, @stahlstift
// ---

/** @type {import('http').METHODS} */
type Methods = 'ACL' | 'BIND' | 'CHECKOUT' | 'CONNECT' | 'COPY' | 'DELETE' | 'GET' | 'HEAD' | 'LINK' | 'LOCK' |'M-SEARCH' | 'MERGE' | 'MKACTIVITY' |'MKCALENDAR' | 'MKCOL' | 'MOVE' |'NOTIFY' | 'OPTIONS' | 'PATCH' | 'POST' | 'PRI' | 'PROPFIND' |  'PROPPATCH' |  'PURGE' | 'PUT' | 'REBIND' | 'REPORT' | 'SEARCH' | 'SOURCE' | 'SUBSCRIBE' | 'TRACE' | 'UNBIND' | 'UNLINK' | 'UNLOCK' | 'UNSUBSCRIBE';

type Pattern = RegExp | string;

declare class Trouter<T = Function> {
	find(method: Methods, url: string): {
		params: Record<string, string>;
		handlers: T[];
	};
	add(method: Methods, pattern: Pattern, ...handlers: T[]): this;
	use(pattern: Pattern, ...handlers: T[]): this;
	all(pattern: Pattern, ...handlers: T[]): this;
	get(pattern: Pattern, ...handlers: T[]): this;
	head(pattern: Pattern, ...handlers: T[]): this;
	patch(pattern: Pattern, ...handlers: T[]): this;
	options(pattern: Pattern, ...handlers: T[]): this;
	connect(pattern: Pattern, ...handlers: T[]): this;
	delete(pattern: Pattern, ...handlers: T[]): this;
	trace(pattern: Pattern, ...handlers: T[]): this;
	post(pattern: Pattern, ...handlers: T[]): this;
	put(pattern: Pattern, ...handlers: T[]): this;
}

type Promisable<T> = Promise<T> | T;
type ListenCallback = () => Promisable<void>;

interface IError extends Error {
	code?: number;
	status?: number;
	details?: any;
}

type NextHandler = (err?: string | IError) => Promisable<void>;
type ErrorHandler<T extends Request = Request> = (err: string | IError, req: T, res: Response, next: NextHandler) => Promisable<void>;
type Middleware<T extends IncomingMessage = Request> = (req: T & Request, res: Response, next: NextHandler) => Promisable<void>;

type Response = ServerResponse;

interface Request extends IncomingMessage {
	url: string;
	method: string;
	originalUrl: string;
	params: Record<string, string>;
	path: string;
	search: string;
	query: Record<string,string>;
	body?: any;
	_decoded?: true;
	_parsedUrl: ParsedURL;
}

interface Polka<T extends Request = Request> extends Trouter<Middleware<T>> {
	readonly server: Server;
	readonly wares: Middleware<T>[];

	readonly onError: ErrorHandler<T>;
	readonly onNoMatch: Middleware<T>;

	readonly handler: Middleware<T>;
	parse: (req: IncomingMessage) => ParsedURL;

	use(pattern: RegExp|string, ...handlers: (Polka<T> | Middleware<T>)[]): this;
	use(...handlers: (Polka<T> | Middleware<T>)[]): this;

	listen(port?: number, hostname?: string, backlog?: number, callback?: ListenCallback): this;
	listen(port?: number, hostname?: string, callback?: ListenCallback): this;
	listen(port?: number, backlog?: number, callback?: ListenCallback): this;
	listen(port?: number, callback?: ListenCallback): this;
	listen(path: string, backlog?: number, callback?: ListenCallback): this;
	listen(path: string, callback?: ListenCallback): this;
	listen(options: ListenOptions, callback?: ListenCallback): this;
	listen(handle: any, backlog?: number, callback?: ListenCallback): this;
	listen(handle: any, callback?: ListenCallback): this;
}

interface ServeOptions {
    base?: string;
    root?: string;
    port?: number;
}
declare function serve(options?: ServeOptions): Promise<Polka<Request>>;

declare function createServer(root?: string, // for backwards compatibility
serverOptions?: ServerOptions & {
    base?: string;
}, restartServer?: () => Promise<void>, config?: SiteConfig): Promise<vite.ViteDevServer>;

declare function cacheAllGitTimestamps(root: string, pathspec?: string[]): Promise<void>;
declare function getGitTimestamp(file: string): Promise<number>;

export { type AdditionalConfigExport, type AdditionalConfigFn, type ContentData, type ContentOptions, type LoaderModule, type MarkdownOptions, type MarkdownRenderer, type RawConfigExports, type ResolvedRouteConfig, type RouteModule, type ScaffoldOptions, ScaffoldThemeType, type ServeOptions, type SiteConfig, type ThemeOptions, type TransformContext, type TransformPageContext, type UserConfig, type UserConfigExport, type UserConfigFn, build, cacheAllGitTimestamps, createContentLoader, createMarkdownRenderer, createServer, defineAdditionalConfig, defineConfig, defineConfigWithTheme, defineLoader, defineRoutes, disposeMdItInstance, getGitTimestamp, init, isAdditionalConfigFile, mergeConfig, postcssIsolateStyles, resolveConfig, resolvePages, resolveSiteData, resolveSiteDataByRoute, resolveUserConfig, scaffold, serve };
