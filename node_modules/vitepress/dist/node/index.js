import { normalizePath } from 'vite';
export { loadEnv } from 'vite';
import { n as normalizeGlob, g as glob, c as createMarkdownRenderer, p as pMap, f as fs, m as matter, s as selectorParser } from './chunk-CCYAX98b.js';
export { S as ScaffoldThemeType, b as build, a as cacheAllGitTimestamps, d as createServer, e as defineAdditionalConfig, h as defineConfig, i as defineConfigWithTheme, j as defineLoader, k as defineRoutes, l as disposeMdItInstance, o as getGitTimestamp, q as init, r as isAdditionalConfigFile, t as mergeConfig, u as resolveConfig, v as resolvePages, w as resolveSiteData, x as resolveSiteDataByRoute, y as resolveUserConfig, z as scaffold, A as serve } from './chunk-CCYAX98b.js';
import path from 'node:path';
import 'node:crypto';
import 'node:module';
import 'node:url';
import 'node:process';
import 'node:fs/promises';
import 'node:fs';
import 'fs';
import 'node:events';
import 'node:stream';
import 'node:string_decoder';
import 'path';
import 'util';
import 'fs/promises';
import 'timers/promises';
import 'os';
import 'node:util';
import 'node:readline';
import 'node:child_process';
import 'node:zlib';
import 'node:stream/promises';
import '@vue/shared';
import 'node:tty';
import 'node:http';
import 'node:timers';
import 'node:querystring';
import 'constants';
import 'stream';
import 'assert';
import 'url';
import 'module';
import '@shikijs/transformers';
import 'shiki';
import 'child_process';
import 'minisearch';

function createContentLoader(watch, options = {}) {
  const config = global.VITEPRESS_CONFIG;
  if (!config) {
    throw new Error(
      "content loader invoked without an active vitepress process, or before vitepress config is resolved."
    );
  }
  const cache = /* @__PURE__ */ new Map();
  watch = normalizeGlob(watch, config.srcDir);
  return {
    watch,
    options: { globOptions: options.globOptions },
    async load(files) {
      files ??= await glob(watch, {
        absolute: true,
        ...options.globOptions
      });
      const md = await createMarkdownRenderer(
        config.srcDir,
        config.markdown,
        config.site.base,
        config.logger
      );
      const raw = await pMap(
        files,
        async (file) => {
          if (!file.endsWith(".md")) return null;
          const timestamp = fs.statSync(file).mtimeMs;
          const cached = cache.get(file);
          if (cached && timestamp === cached.timestamp) return cached.data;
          const src = fs.readFileSync(file, "utf-8");
          const renderExcerpt = options.excerpt;
          const { data: frontmatter, excerpt } = matter(
            src,
            typeof renderExcerpt === "string" ? { excerpt_separator: renderExcerpt } : { excerpt: renderExcerpt }
            // gray-matter types are wrong
          );
          const url = "/" + normalizePath(path.relative(config.srcDir, file)).replace(/(^|\/)index\.md$/, "$1").replace(/\.md$/, config.cleanUrls ? "" : ".html");
          const html = options.render ? await md.renderAsync(src) : void 0;
          const renderedExcerpt = renderExcerpt ? excerpt && await md.renderAsync(excerpt) : void 0;
          const data = {
            src: options.includeSrc ? src : void 0,
            html,
            frontmatter,
            excerpt: renderedExcerpt,
            url
          };
          cache.set(file, { data, timestamp });
          return data;
        },
        { concurrency: config.buildConcurrency }
      );
      const filtered = raw.filter((i) => i !== null);
      return options.transform?.(filtered) ?? filtered;
    }
  };
}

function postcssIsolateStyles({
  includeFiles = [/vp-doc\.css/, /base\.css/],
  ignoreFiles,
  prefix = ":not(:where(.vp-raw, .vp-raw *))"
} = {}) {
  const prefixNodes = selectorParser().astSync(prefix).first.nodes;
  return (
    /* prettier-ignore */
    {
      postcssPlugin: "postcss-isolate-styles",
      Once(root) {
        const file = root.source?.input.file;
        if (file && includeFiles?.length && !includeFiles.some((re) => re.test(file))) return;
        if (file && ignoreFiles?.length && ignoreFiles.some((re) => re.test(file))) return;
        root.walkRules((rule) => {
          if (!rule.selector || rule.selector.includes(prefix)) return;
          if (rule.parent?.type === "atrule" && /\bkeyframes$/i.test(rule.parent.name)) return;
          rule.selector = selectorParser((selectors) => {
            selectors.each((sel) => {
              if (!sel.nodes.length) return;
              const insertionIndex = sel.nodes.findLastIndex((n) => n.type !== "pseudo") + 1;
              sel.nodes.splice(insertionIndex, 0, ...prefixNodes.map((n) => n.clone()));
            });
          }).processSync(rule.selector);
        });
      }
    }
  );
}

export { createContentLoader, createMarkdownRenderer, postcssIsolateStyles };
